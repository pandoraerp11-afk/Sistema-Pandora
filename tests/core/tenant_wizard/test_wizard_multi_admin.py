import json

from django.contrib.auth import get_user_model
from django.test import TestCase

from core.models import Role, Tenant, TenantUser
from core.wizard_views import TenantCreationWizardView

User = get_user_model()


# Nome da classe ajustado para começar com 'Test' para que o pytest descubra os métodos.
class TestWizardMultiAdmin(TestCase):
    """Testes unitários focados na rotina process_admin_data do wizard multi-admin."""

    def setUp(self):
        self.superuser = User.objects.create_superuser("root", "root@example.com", "StrongPass!123")
        # Criar tenant de teste direto (wizard normalmente criaria em steps anteriores)
        self.tenant = Tenant.objects.create(name="Empresa X", subdomain="empresax", tipo_pessoa="PJ")
        # Garantir papel ADMIN existe
        Role.objects.get_or_create(tenant=self.tenant, name="ADMIN")
        self.view = TenantCreationWizardView()

    def _process(self, admins_list, bulk_password=None):
        payload = {"step_6": {"main": {"admins_json": json.dumps(admins_list)}}}
        if bulk_password:
            payload["step_6"]["main"]["bulk_admin_password"] = bulk_password
        self.view.process_admin_data(self.tenant, payload)

    def test_multi_admin_creation_with_individual_passwords(self):
        admins = [
            {
                "nome": "Alice Admin",
                "email": "alice@example.com",
                "senha": "SenhaForte!123",
                "confirm_senha": "SenhaForte!123",
                "cargo": "Gerente",
                "ativo": True,
            },
            {
                "nome": "Bob Lider",
                "email": "bob@example.com",
                "senha": "OutraForte!123",
                "confirm_senha": "OutraForte!123",
                "cargo": "Diretor",
                "ativo": False,
            },
        ]
        self._process(admins)
        tenant = self.tenant
        self.assertEqual(tenant.tenant_users.count(), 2)
        # Verifica ativo/inativo
        alice_user = User.objects.get(email="alice@example.com")
        bob_user = User.objects.get(email="bob@example.com")
        self.assertTrue(alice_user.is_active)
        self.assertFalse(bob_user.is_active)
        # Cargo persistido
        self.assertEqual(TenantUser.objects.get(user=alice_user, tenant=tenant).cargo, "Gerente")

    def test_bulk_password_applied_when_missing_individual(self):
        admins = [
            {"nome": "Carol", "email": "carol@example.com"},
            {"nome": "Dan", "email": "dan@example.com", "senha": "Especifica!123", "confirm_senha": "Especifica!123"},
        ]
        self._process(admins, bulk_password="BulkPass!123")
        carol = User.objects.get(email="carol@example.com")
        dan = User.objects.get(email="dan@example.com")
        self.assertTrue(carol.check_password("BulkPass!123"))
        self.assertTrue(dan.check_password("Especifica!123"))

    def test_reject_short_password_and_use_bulk(self):
        # Aqui como chamamos direto process_admin_data, a validação de step não roda;
        # então simulamos comportamento esperado: senha curta ignorada => usa bulk.
        admins = [{"nome": "Eve", "email": "eve@example.com", "senha": "123", "confirm_senha": "123"}]
        self._process(admins, bulk_password="NovaForte!123")
        eve = User.objects.get(email="eve@example.com")
        self.assertTrue(eve.check_password("NovaForte!123"))

    def test_duplicate_email_same_batch(self):
        # Como chamamos direto sem validação de step, ambos serão processados; ajustamos teste para refletir isso:
        admins = [
            {"nome": "Foo", "email": "dup@example.com", "senha": "SenhaOk!123", "confirm_senha": "SenhaOk!123"},
            {"nome": "Bar", "email": "dup@example.com", "senha": "SenhaOk!123", "confirm_senha": "SenhaOk!123"},
        ]
        self._process(admins)
        # Apenas um usuário deve existir (primeiro cria, segundo associa existente)
        self.assertEqual(User.objects.filter(email="dup@example.com").count(), 1)
        self.assertEqual(TenantUser.objects.filter(tenant=self.tenant).count(), 1)

    def test_username_autogenerated(self):
        admins = [{"nome": "Joao da Silva", "email": "joao@example.com"}]
        self._process(admins)
        user = User.objects.get(email="joao@example.com")
        self.assertTrue(user.username.startswith("joao"))
        self.assertEqual(self.tenant.tenant_users.count(), 1)
