# Generated by Django 5.2.5 on 2025-09-10 17:40

from django.db import migrations
from django.utils.text import slugify
import json


def migrate_data(apps, schema_editor):
    """
    Migra dados de prontuarios.Procedimento para servicos.Servico e servicos.ServicoClinico.
    """
    Procedimento = apps.get_model("prontuarios", "Procedimento")
    Servico = apps.get_model("servicos", "Servico")
    ServicoClinico = apps.get_model("servicos", "ServicoClinico")
    Tenant = apps.get_model("core", "Tenant")
    CategoriaServico = apps.get_model("servicos", "CategoriaServico")

    procedimento_to_servico_map = {}

    default_tenant = Tenant.objects.first()
    if not default_tenant:
        # Em um cenário real, seria melhor parar ou ter uma estratégia clara.
        # Para este script, vamos assumir que pelo menos um tenant existe.
        pass

    for procedimento in Procedimento.objects.all():
        # Mapeia a categoria de 'choices' para um objeto ForeignKey
        categoria_nome = dict(procedimento._meta.get_field("categoria").choices).get(
            procedimento.categoria, procedimento.categoria
        )
        # Garantir slug único para a categoria (o histórico não executa save customizado)
        base_cat_slug = slugify(categoria_nome) or f"categoria-{procedimento.id}"
        cat_slug = base_cat_slug
        cat_counter = 1
        while CategoriaServico.objects.filter(slug=cat_slug).exists():
            cat_slug = f"{base_cat_slug}-{cat_counter}"
            cat_counter += 1

        # Buscar por nome (único). Se existir, reutiliza. Caso contrário cria com slug definido.
        try:
            categoria_obj = CategoriaServico.objects.get(nome=categoria_nome)
        except CategoriaServico.DoesNotExist:
            categoria_obj = CategoriaServico.objects.create(
                nome=categoria_nome,
                descricao=f"Categoria migrada de {procedimento.categoria}",
                slug=cat_slug,
                ativo=True,
            )

        # Gerar slug único manualmente (model histórico não tem lógica de save custom)
        base_slug = slugify(procedimento.nome) or f"servico-{procedimento.id}"
        slug = base_slug
        counter = 1
        while Servico.objects.filter(slug=slug).exists():
            slug = f"{base_slug}-{counter}"
            counter += 1

        # 1. Criar o Servico base
        servico_obj = Servico.objects.create(
            tenant=procedimento.tenant,
            is_clinical=True,
            nome_servico=procedimento.nome,
            slug=slug,
            descricao=procedimento.descricao,
            preco_base=procedimento.valor_base,
            categoria=categoria_obj,
            ativo=procedimento.ativo,
        )

        # 2. Criar o perfil clínico
        ServicoClinico.objects.create(
            servico=servico_obj,
            duracao_estimada=procedimento.duracao_estimada,
            requisitos_pre_procedimento=procedimento.requisitos_pre_procedimento,
            contraindicacoes=procedimento.contraindicacoes,
            cuidados_pos_procedimento=procedimento.cuidados_pos_procedimento,
            requer_anamnese=procedimento.requer_anamnese,
            requer_termo_consentimento=procedimento.requer_termo_consentimento,
            permite_fotos_evolucao=procedimento.permite_fotos_evolucao,
            intervalo_minimo_sessoes=procedimento.intervalo_minimo_sessoes,
        )

        # 3. Salvar o mapeamento
        procedimento_to_servico_map[procedimento.id] = servico_obj.id

    # Salvar o mapa em arquivo (somente para auditoria / futura referência).
    # Em ambientes como App Engine (filesystem read-only) só /tmp é gravável.
    import os

    target_path = "/tmp/procedimento_servico_map.json"
    try:
        with open(target_path, "w") as f:
            json.dump(procedimento_to_servico_map, f)
    except OSError:
        # Fallback silencioso: não falha a migração se não conseguir gravar.
        # Poderíamos também logar via print (aparece em stdout de migração).
        print("[WARN] Não foi possível gravar mapa de procedimentos em", target_path)


def reverse_migrate_data(apps, schema_editor):
    """
    Função para reverter a migração.
    """
    Servico = apps.get_model("servicos", "Servico")
    Servico.objects.filter(is_clinical=True).delete()
    import os

    tmp_path = "/tmp/procedimento_servico_map.json"
    if os.path.exists(tmp_path):
        try:
            os.remove(tmp_path)
        except OSError:
            pass


class Migration(migrations.Migration):

    dependencies = [
        ("servicos", "0002_servicoclinico_servico_is_clinical_servico_tenant"),
        ("prontuarios", "0001_initial"),
        ("core", "0001_initial"),
    ]

    operations = [
        migrations.RunPython(migrate_data, reverse_code=reverse_migrate_data),
    ]
